{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/types.coffee"
  ],
  "names": [],
  "mappings": "AAEA;EAAA;AAAA,MAAA,GAAA,EAAA,UAAA,EAAA,KAAA,EAAA,IAAA,EAAA,gBAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,CAAA,CAAE,KAAF,EACE,IADF,EAEE,OAFF,EAGE,IAHF,EAIE,IAJF,EAKE,IALF,CAAA,GAK4B,GAAG,CAAC,GAAG,CAAC,WAAR,CAAoB,sBAApB,CAL5B;;EAMA,CAAA,CAAE,GAAF,EACE,IADF,CAAA,GAC4B,GAAG,CAAC,GADhC;;EAEA,CAAA,CAAE,gBAAF,CAAA,GAA4B,GAAG,CAAC,GAAhC;;EACA,CAAA,CAAE,UAAF,CAAA,GAA4B,GAAG,CAAC,QAAhC,EAdA;;;EAkBA,MAAM,CAAC,OAAP,GAAiB,QAAA,CAAE,GAAF,CAAA;AACjB,QAAA,OAAA,EAAA;IAAE,KAAA,GAAc,IAAI,CAAE,OAAA,CAAQ,WAAR,CAAF,CAAuB,CAAC,SAA5B,CAAA;IACd,CAAA,CAAE,OAAF,CAAA,GAAc,KAAd,EADF;;IAIE,OAAO,CAAC,iBAAR,CAA0B,QAAA,CAAE,CAAF,CAAA;MACxB,KAAoB,IAAC,CAAA,GAAG,CAAC,KAAL,CAAW,CAAX,CAApB;AAAA,eAAO,MAAP;;MACA,KAAoB,CAAC,CAAC,OAAtB;AAAA,eAAO,MAAP;;AACA,aAAO;IAHiB,CAA1B,EAJF;;IAUE,OAAO,CAAC,WAAR,CACE;MAAA,GAAA,EAAK,mBAAL;MACA,MAAA,EAAQ,QAAA,CAAE,CAAF,CAAA;AACZ,YAAA;QAAM,IAAG,IAAC,CAAA,GAAG,CAAC,IAAL,CAAU,CAAV,CAAH;UACE,CAAA,GAAI,IAAI,MAAJ,CAAa,gBAAA,CAAiB,CAAjB,CAAb,EAAmC,IAAnC,EADN;SAAA,MAAA;UAGE,KAAgB,IAAC,CAAA,GAAG,CAAC,KAAL,CAAW,CAAX,CAAhB;AAAA,mBAAO,EAAP;;UACA,CAAA,GAAI,UAAA,CAAW,CAAX,EAAc;YAAE,MAAA,EAAQ;UAAV,CAAd,EAJN;;AAKA,eAAO;MAND;IADR,CADF,EAVF;;IAqBE,OAAO,CAAC,aAAR,CACE;MAAA,MAAA,EACE;QAAA,OAAA,EAAc,aAAd;QACA,WAAA,EAAc;MADd,CADF;MAGA,OAAA,EACE;QAAA,OAAA,EAAc,IAAd;QACA,WAAA,EAAc;MADd,CAJF;MAMA,MAAA,EAAQ,QAAA,CAAE,CAAF,CAAA;AACZ,YAAA;QAAM,IAAQ,IAAC,CAAA,GAAG,CAAC,IAAL,CAAY,CAAZ,CAAR;UAA4B,CAAA,GAAI;YAAE,OAAA,EAAS;UAAX,EAAhC;SAAA,MACK,IAAG,IAAC,CAAA,GAAG,CAAC,KAAL,CAAY,CAAZ,CAAH;UAAuB,CAAA,GAAI;YAAE,OAAA,EAAS;UAAX,EAA3B;SAAA,MACA,IAAG,IAAC,CAAA,GAAG,CAAC,MAAL,CAAY,CAAZ,CAAH;UAAuB,CAAA,GAAI,EAA3B;SAAA,MAAA;AACuB,iBAAO,EAD9B;;QAEL,CAAC,CAAC,OAAF,GAAY,IAAC,CAAA,MAAM,CAAC,WAAR,CAAoB,CAAC,CAAC,OAAtB;AACZ,eAAO,CAAE,GAAA,IAAC,CAAA,QAAQ,CAAC,aAAa,CAAC,OAA1B,EAAsC,GAAA,CAAtC;MAND;IANR,CADF,EArBF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8GE,WAAO;EA/GQ;AAlBjB",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ debug\n  info\n  whisper\n  warn\n  urge\n  help }                  = GUY.trm.get_loggers 'DBAY-SQL-LEXER/types'\n{ rpr\n  echo }                  = GUY.trm\n{ escape_for_regex }      = GUY.str\n{ copy_regex }            = GUY.samesame\n\n\n#-----------------------------------------------------------------------------------------------------------\nmodule.exports = ( cfg ) ->\n  types       = new ( require 'intertype' ).Intertype()\n  { declare } = types\n\n  #---------------------------------------------------------------------------------------------------------\n  declare.lxr_unicode_regex ( x ) ->\n    return false unless @isa.regex x\n    return false unless x.unicode\n    return true\n\n  #---------------------------------------------------------------------------------------------------------\n  declare.lxr_matcher\n    isa: 'lxr_unicode_regex'\n    create: ( x ) ->\n      if @isa.text x\n        R = new RegExp ( escape_for_regex x ), 'uy'\n      else\n        return x unless @isa.regex x\n        R = copy_regex x, { sticky: true, }\n      return R\n\n  #---------------------------------------------------------------------------------------------------------\n  declare.lxr_token_cfg\n    fields:\n      matcher:      'lxr_matcher'\n      consolidate:  'boolean'\n    default:\n      matcher:      null\n      consolidate:  false\n    create: ( x ) ->\n      if      @isa.text   x then  R = { matcher: x, }\n      else if @isa.regex  x then  R = { matcher: x, }\n      else if @isa.object x then  R = x\n      else                        return x\n      R.matcher = @create.lxr_matcher R.matcher\n      return { @registry.lxr_token_cfg.default..., R..., }\n\n  # #---------------------------------------------------------------------------------------------------------\n  # declare.lxr_token_entry\n  #   isa: 'lxr_unicode_regex.or.lxr_token_cfg'\n\n  # #---------------------------------------------------------------------------------------------------------\n  # declare.dbm_anchored_regex ( x ) ->\n  #   return false unless @isa.regex x\n  #   return false if x.global\n  #   return false if x.sticky\n  #   return true\n\n  # #---------------------------------------------------------------------------------------------------------\n  # declare.dbm_mode ( x ) -> x in [ 'strict', 'practical', ]\n\n  # #---------------------------------------------------------------------------------------------------------\n  # declare.dbm_constructor_cfg\n  #   fields:\n  #     prefix:               'nonempty.text'\n  #     escape:               'nonempty.text'\n  #     mode:                 'dbm_mode'\n  #     _any_name_re:         'regex'\n  #     _bare_name_re:        'dbm_global_regex'\n  #     _paren_name_re:       'dbm_global_regex'\n  #     _start_paren_name_re: 'dbm_anchored_regex'\n  #     _escaped_prefix_re:   'dbm_global_regex'\n  #     _prefix_esc:          'nonempty.text'\n  #     _escape_esc:          'nonempty.text'\n  #   default:\n  #     prefix:               '@'\n  #     # escape:               '\\\\'\n  #     escape:               '%'\n  #     mode:                 'practical'\n  #     # _any_name_re:              /[\\p{Letter}_][\\p{Letter}_\\d]*/u\n  #     ### this regex lifted from Intertype@0.105.1/declarations ###\n  #     _prefix_esc:          null\n  #     _escape_esc:          null\n  #     _any_name_re:         null\n  #     _bare_name_re:        null\n  #     _paren_name_re:       null\n  #     _start_paren_name_re: null\n  #     _escaped_prefix_re:   null\n  #     # _global_name_re:  null\n  #   create: ( cfg ) ->\n  #     R = { @registry.dbm_constructor_cfg.default..., cfg..., }\n  #     return R unless @isa.nonempty.text R.prefix\n  #     #.....................................................................................................\n  #     return R if R._prefix_esc?\n  #     return R if R._escape_esc?\n  #     return R if R._any_name_re?\n  #     return R if R._bare_name_re?\n  #     return R if R._paren_name_re?\n  #     return R if R._start_paren_name_re?\n  #     return R if R._escaped_prefix_re?\n  #     #.....................................................................................................\n  #     ### TAINT harmonize naming, use either `re` or `rx` ###\n  #     R._prefix_esc           = escape_for_regex R.prefix\n  #     R._escape_esc           = escape_for_regex R.escape\n  #     R._any_name_re          = rx.get_rx_for_any_name          R\n  #     R._bare_name_re         = rx.get_rx_for_bare_name         R\n  #     R._paren_name_re        = rx.get_rx_for_paren_name        R\n  #     R._start_paren_name_re  = rx.get_rx_for_start_paren_name  R\n  #     R._escaped_prefix_re    = rx.get_rx_for_escaped_prefix    R\n  #     R._escaped_escape_re    = rx.get_rx_for_escaped_escape    R\n  #     # R._escaped_prefix_re    = /// #{R._escape_esc} #{R._prefix_esc} ///gu\n  #     ### prefix, escape must not match chrs.*.forbidden.tail ###\n  #     ### prefix, escape must be different from each other (can be substrings???) ###\n  #     #.....................................................................................................\n  #     declare.dbm_parameter_list ( x ) ->\n  #       return false unless @isa.list.of.nonempty.text x\n  #       return false unless x.every ( p ) -> ( p.match R._bare_name_re )?\n  #       return true\n  #     return R\n\n  #---------------------------------------------------------------------------------------------------------\n  return types\n"
  ]
}